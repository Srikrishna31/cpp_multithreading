
import clang.cindex
from clang.cindex import Cursor, CursorKind
import argparse
from pathlib import Path
import json
from typing import List, Dict, Self, Tuple

class Arguments:
    def __init__(self: Self) -> None:
        self.arguments = {}

    def with_manifest_file(self: Self) -> Self:
        self.arguments['manifest_file'] = True
        return self

    def with_validation(self: Self) -> Self:
        self.arguments['validation_file'] = True
        return self

    def with_workspace_path(self: Self) -> Self:
        self.arguments['workspace_path'] = True
        return self

    def build(self: Self) -> argparse.Namespace:
        parser = argparse.ArgumentParser(
            description="Check for symbol definitions in C/C++ source files, and detect ODR violations if any."
        )
        if "manifest_file" in self.arguments:
            parser.add_argument(
                '--manifest_file',
                type=Path,
                required=True,
                help='Path to the JSON manifest file containing source file paths, include paths, compiler arguments.',
            )
        if "validation_file" in self.arguments:
            parser.add_argument(
                '--validation_file',
                type=Path,
                required=True,
                help='Validation file is the output that would be generated by SymbolChecker containing ODR violations if any.',
            )
        if "workspace_path" in self.arguments:
            parser.add_argument(
                '--workspace_path',
                type=Path,
                required=True,
                help='File containing workspace path, which is not provided by Bazel aspects directly.'
            )
        return parser.parse_args()

class SymbolChecker:
    def __init__(self: Self, manifest: Path, validation_file: Path, workspace_path: Path) -> None:
        if not manifest.exists():
            raise FileNotFoundError(f"Manifest file {manifest} does not exist.")
        if not workspace_path.exists():
            raise FileNotFoundError(f"Workspace path file {workspace_path} does not exist.")
        if validation_file.exists():
            validation_file.unlink()

        self.manifest:Path = manifest
        self.validation_file: Path = validation_file
        with open(workspace_path) as f:
            self.workspace_path = Path(f.readline().strip())
        with open(self.manifest) as f:
            self.data = json.load(f)
        self.index = clang.cindex.Index.create()
        self.symbols: Dict[str, Tuple[CursorKind, str]] = {}
        self.errors: List[str] = []

        self.process_includes()

    def process_includes(self: Self) -> None:
        self.data["includes"] = [f"{self.workspace_path / inc}" for inc in self.data.get("includes", [])]
        self.data["includes"].append(f"-I{self.workspace_path}")

        t = [f"-I{self.workspace_path / f}" for f in self.data.get("framework_includes", [])]
        self.data["includes"].extend(t)

        print(self.data["includes"])

    @staticmethod
    def get_fully_qualified_name(cursor: Cursor) -> str:
        if cursor is None or cursor.kind == CursorKind.TRANSLATION_UNIT:
            return ""
        else:
            res = SymbolChecker.get_fully_qualified_name(c.semantic_parent)
            if res != "":
                return f"{res}::{cursor.spelling}"

        return cursor.spelling

    def collect_definitions(self: Self, tupath: str, args: List[str]) -> List[Tuple[str, CursorKind, str, str]]:
        tu = self.index.parse(tupath, args=args)
        # print(f"AST for {tupath}:")
        # SymbolChecker.print_ast(tu.cursor)
        print(f"-------------Errors for {tupath}-------------")
        SymbolChecker.print_errors(tu.diagnostics)
        print("----------------------------------------------")
        definitions = []

        def visit(node):
            # Skip namespace symbols, since they can be defined in multiple translation units (files)
            if (node.kind.is_declaration() or node.is_definition()) and node.kind != CursorKind.NAMESPACE:
                fqname = SymbolChecker.get_fully_qualified_name(node.referenced)
                definitions.append((fqname, node.kind, node.location.file.name, node.location.line))

            for child in node.get_children():
                visit(child)

        visit(tu.cursor)

        if tu.diagnostics:
            SymbolChecker.print_errors(tu.diagnostics)

        return definitions

    def validate(self: Self) -> None:
        args = self.data["args"] + self.data["includes"] + self.data["defines"]
        srcs = self.data["srcs"]
        print(f"Processing {self.data['tgt']} ...")
        for s in srcs:
            src_file_path = self.workspace_path / s
            print(f"Collection definitions from {src_file_path} ...")
            symbols = self.collect_definitions(src_file_path, args)
            for name, kind, file, line in symbols:
                if name in self.symbols:
                    err = (
                        f"ODR violation? Symbol '{name}' of kind '{kind.name}' defined in both {self.sybmls[name]} and {file}:{line} {kind}"
                    )
                    print(err)
                    self.error_list.append(err)
                else:
                    self.symbols[name] = (kind, f"{file}:{line}")

            with open(self.validation_file, "w") as f:
                if self.error_list:
                    f.writelines(self.error_list)
                else:
                    f.write("No ODR violations found.\n")

    @staticmethod
    def print_ast(node: Cursor, depth: int = 0) -> None:
        print("  " * depth + f"{node.kind} - {node.spelling}")
        for child in node.get_children():
            SymbolChecker.print_ast(child, depth + 1)

    @staticmethod
    def print_errors(diagnostics) -> None:
        for error in diagnostics:
            print(f"{error.severity}: {error.spelling} at")
            print(f"Location: {error.location.file}:{error.location.line}:{error.location.column}")
            print(f"Category: {error.category_name}")
            print("-" * 40)

def check_symbols(arguments: argparse.Namespace) -> None:
    checker = SymbolChecker(arguments.manifest_file, arguments.validation_file, arguments.workspace_path)
    checker.validate()

def main():
    args: argparse.Namespace = Arguments().with_manifest_file().with_validation().with_workspace_path().build()
    check_symbols(args)

if __name__ == "__main__":
    main()