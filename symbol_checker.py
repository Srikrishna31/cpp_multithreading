"""
Symbol Checker - One Definition Rule (ODR) Violation Detector

This module provides functionality to detect ODR violations in C/C++ projects
by parsing source files with libclang and identifying duplicate symbol definitions
across translation units.

The script is designed to be called by Bazel's check_symbols rule, which provides
compilation information via a JSON manifest file.

Key Components:
    - Arguments: Builder pattern for command-line argument parsing
    - SymbolChecker: Main class that performs symbol analysis using libclang
    - Utility functions: AST traversal and error reporting

Usage:
    python symbol_checker.py \\
        --manifest_file <path_to_manifest.json> \\
        --validation_file <path_to_output.txt> \\
        --workspace_path <path_to_workspace_file.txt>

Dependencies:
    - libclang: Python bindings for Clang's C API
    - Standard library: argparse, pathlib, json, typing

"""

import clang.cindex
from clang.cindex import Cursor, CursorKind
import argparse
from pathlib import Path
import json
from typing import List, Dict, Self, Tuple, Any


class Arguments:
    """Builder pattern for constructing command-line arguments.

    This class provides a fluent interface for building argparse configuration.
    It allows selective addition of command-line arguments through chained method calls.

    Attributes:
        arguments (Dict[str, bool]): Dictionary tracking which arguments to include

    Example:
        args = Arguments() \\
            .with_manifest_file() \\
            .with_validation() \\
            .with_workspace_path() \\
            .build()
    """

    def __init__(self: Self) -> None:
        self.arguments = {}

    def with_manifest_file(self: Self) -> Self:
        self.arguments["manifest_file"] = True
        return self

    def with_validation(self: Self) -> Self:
        self.arguments["validation_file"] = True
        return self

    def with_workspace_path(self: Self) -> Self:
        self.arguments["workspace_path"] = True
        return self

    def build(self: Self) -> argparse.Namespace:
        parser = argparse.ArgumentParser(
            description="Check for symbol definitions in C/C++ source files, and detect ODR violations if any."
        )
        if "manifest_file" in self.arguments:
            parser.add_argument(
                "--manifest_file",
                type=Path,
                required=True,
                help="Path to the JSON manifest file containing source file paths, include paths, compiler arguments.",
            )
        if "validation_file" in self.arguments:
            parser.add_argument(
                "--validation_file",
                type=Path,
                required=True,
                help="Validation file is the output that would be generated by SymbolChecker containing ODR violations if any.",
            )
        if "workspace_path" in self.arguments:
            parser.add_argument(
                "--workspace_path",
                type=Path,
                required=True,
                help="File containing workspace path, which is not provided by Bazel aspects directly.",
            )
        return parser.parse_args()


class SymbolChecker:
    """Detects One Definition Rule (ODR) violations in C/C++ code.

    This class uses libclang to parse C/C++ source files and extract symbol definitions.
    It maintains a registry of all seen symbols and detects when the same symbol is
    defined in multiple translation units, which violates the ODR.

    Attributes:
        manifest (Path): Path to the JSON manifest file with compilation info
        validation_file (Path): Path to the output file for violation reports
        workspace_path (Path): Absolute path to the Bazel workspace root
        data (Dict): Parsed manifest data (sources, includes, args, defines)
        index (clang.cindex.Index): Libclang index for parsing translation units
        symbols (Dict[str, Tuple[CursorKind, str]]): Registry of seen symbols
        errors (List[str]): List of ODR violation error messages

    The ODR states that:
        - Each translation unit can have at most one definition of any symbol
        - If a symbol appears in multiple translation units, all definitions must be identical
    """

    def __init__(
        self: Self, manifest: Path, validation_file: Path, workspace_path: Path
    ) -> None:
        """Initialize the SymbolChecker with input files.

        Args:
            manifest: Path to JSON manifest file containing compilation information
            validation_file: Path where validation results will be written
            workspace_path: Path to file containing workspace root path

        Raises:
            FileNotFoundError: If manifest or workspace_path file doesn't exist

        Side Effects:
            - Deletes existing validation_file if present
            - Reads workspace path from workspace_path file
            - Loads and parses manifest JSON
            - Creates libclang Index
            - Processes include paths
        """
        if not manifest.exists():
            raise FileNotFoundError(f"Manifest file {manifest} does not exist.")
        if not workspace_path.exists():
            raise FileNotFoundError(
                f"Workspace path file {workspace_path} does not exist."
            )
        if validation_file.exists():
            validation_file.unlink()

        self.manifest: Path = manifest
        self.validation_file: Path = validation_file
        with open(workspace_path) as f:
            self.workspace_path: Path = Path(f.readline().strip())
        with open(self.manifest) as f:
            self.data: Any = json.load(f)
        self.index = clang.cindex.Index.create()
        self.symbols: Dict[str, Tuple[CursorKind, str]] = {}
        self.error_list: List[str] = []

        self.pre_process_data()

    def pre_process_data(self: Self) -> None:
        """Process and normalize include paths for compilation.

        Converts relative include paths from the manifest to absolute paths
        by prepending the workspace path. Adds -I prefix for compiler not compatibility.
        """

        self.data["includes"] = [
            f"{self.workspace_path / inc}" for inc in self.data.get("includes", [])
        ]
        self.data["includes"].append(f"-I{self.workspace_path}")

        t = [
            f"-I{self.workspace_path / f}"
            for f in self.data.get("framework_includes", [])
        ]
        self.data["includes"].extend(t)

        self.data["srcs"] = list(
            filter(
                lambda x: not x.endswith((".h", ".hpp", ".hxx")),
                self.data.get("srcs", []),
            )
        )

    @staticmethod
    def get_fully_qualified_name(cursor: Cursor) -> str:
        if cursor is None or cursor.kind == CursorKind.TRANSLATION_UNIT:
            return ""
        else:
            res = SymbolChecker.get_fully_qualified_name(cursor.semantic_parent)
            if res != "":
                return f"{res}::{cursor.spelling}"

        return cursor.spelling

    def collect_definitions(
        self: Self, tupath: str, args: List[str]
    ) -> List[Tuple[str, CursorKind, str, str]]:
        """Parse a translation unit and collect all symbol definitions.

        Uses libclang to parse a C/C++ source file and traverse its AST,
        collecting information about all defined symbols.

        Args:
            tupath: Path to the source file to parse
            args: Compiler arguments (includes, defines, flags)

        Returns:
            List of tuples, each containing:
                - Fully qualified symbol name (str)
                - Symbol kind (CursorKind) - function, class, variable, etc.
                - File path where defined (str)
                - Line number where defined (int)
        """
        tu = self.index.parse(tupath, args=args)
        # print(f"AST for {tupath}:")
        # SymbolChecker.print_ast(tu.cursor)
        definitions = []

        def visit(node):
            # Skip namespace symbols, since they can be defined in multiple translation units (files)
            if (
                node.kind.is_declaration() or node.is_definition()
            ) and node.kind != CursorKind.NAMESPACE:
                fqname = SymbolChecker.get_fully_qualified_name(node.referenced)
                definitions.append(
                    (fqname, node.kind, node.location.file.name, node.location.line)
                )

            for child in node.get_children():
                visit(child)

        visit(tu.cursor)

        if tu.diagnostics:
            print(f"-------------Errors for {tupath}-------------")
            SymbolChecker.print_errors(tu.diagnostics)
            print("----------------------------------------------")

        return definitions

    def validate(self: Self) -> None:
        """Validate symbols across all source files and detect ODR violations.

        Main validation logic that:
        1. Combines compiler arguments from manifest
        2. Parses each source file to collect symbols
        3. Compares against previously seen symbols
        4. Records ODR violations when duplicates are found
        5. Writes validation report

        ODR Violation Detection:
            If a symbol name is seen twice with the same fully qualified name,
            it's flagged as a potential ODR violation (unless it's a namespace).
        """
        args = self.data["args"] + self.data["includes"] + self.data["defines"]
        srcs = self.data["srcs"]
        print(f"Processing {self.data['tgt']} ...")
        for s in srcs:
            src_file_path = self.workspace_path / s
            print(f"Collection definitions from {src_file_path} ...")
            symbols = self.collect_definitions(src_file_path, args)
            for name, kind, file, line in symbols:
                if name in self.symbols:
                    err = f"ODR violation? Symbol '{name}' of kind '{kind.name}' defined in both {self.symbols[name]} and {file}:{line} {kind}"
                    print(err)
                    self.error_list.append(err)
                else:
                    self.symbols[name] = (kind, f"{file}:{line}")

            with open(self.validation_file, "w") as f:
                if self.error_list:
                    f.writelines(self.error_list)
                else:
                    f.write("No ODR violations found.\n")

    @staticmethod
    def print_ast(node: Cursor, depth: int = 0) -> None:
        print("  " * depth + f"{node.kind} - {node.spelling}")
        for child in node.get_children():
            SymbolChecker.print_ast(child, depth + 1)

    @staticmethod
    def print_errors(diagnostics) -> None:
        for error in diagnostics:
            print(f"{error.severity}: {error.spelling} at")
            print(
                f"Location: {error.location.file}:{error.location.line}:{error.location.column}"
            )
            print(f"Category: {error.category_name}")
            print("-" * 40)


def check_symbols(arguments: argparse.Namespace) -> None:
    checker = SymbolChecker(
        arguments.manifest_file, arguments.validation_file, arguments.workspace_path
    )
    checker.validate()


def main():
    args: argparse.Namespace = (
        Arguments().with_manifest_file().with_validation().with_workspace_path().build()
    )
    check_symbols(args)


if __name__ == "__main__":
    import os

    print(os.getcwd())
    main()
